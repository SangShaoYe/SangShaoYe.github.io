<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>My Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="My Blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="My Blogs">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Blogs">
  
    <link rel="alternate" href="/atom.xml" title="My Blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">My Blogs</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">A man can&#39;t ride your back unless it is bent！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-status" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/24/status/" class="article-date">
  <time datetime="2018-02-24T08:34:07.000Z" itemprop="datePublished">2018-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/24/status/">status</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>一些常见的状态码为：</p>
<p>　　200 - 服务器成功返回网页</p>
<p>　　404 - 请求的网页不存在</p>
<p>　　503 - 服务器超时<br>　　下面提供 HTTP 状态码的完整列表。点击链接可了解详情。您也可以访问 HTTP 状态码上的 W3C 页获取更多信息。</p>
<p>　　1xx(临时响应)</p>
<p>　　表示临时响应并需要请求者继续执行操作的状态码。</p>
<p>　　100(继续)请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p>
<p>　　101(切换协议)请求者已要求服务器切换协议，服务器已确认并准备切换。</p>
<p>　　2xx (成功)<br>　　表示成功处理了请求的状态码。</p>
<p>　　200(成功)服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。</p>
<p>　　201(已创建)请求成功并且服务器创建了新的资源。</p>
<p>　　202(已接受)服务器已接受请求，但尚未处理。</p>
<p>　　203(非授权信息)服务器已成功处理了请求，但返回的信息可能来自另一来源。</p>
<p>　　204(无内容)服务器成功处理了请求，但没有返回任何内容。</p>
<p>　　205(重置内容)服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图(例如，清除表单内容以输入新内容)。</p>
<p>　　206(部分内容)服务器成功处理了部分 GET 请求。</p>
<p>　　3xx (重定向)</p>
<p>　　要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。</p>
<p>　　300(多种选择)针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p>
<p>　　301(永久移动)请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。</p>
<p>　　302(临时移动)服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</p>
<p>　　303(查看其他位置)请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。</p>
<p>　　304(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。<br>　　如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。服务器可以告诉搜索引擎的蜘蛛/机器人 自从上次抓取后网页没有变更，进而节省带宽和开销。<br>　　.<br>　　305(使用代理)请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</p>
<p>　　307(临时重定向)服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</p>
<p>　　4xx(请求错误)</p>
<p>　　这些状态码表示请求可能出错，妨碍了服务器的处理。<br>　　400(错误请求)服务器不理解请求的语法。</p>
<p>　　401(未授权)请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。</p>
<p>　　403(禁止)服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码(您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息)，可能是您的服务器或主机拒绝了 Googlebot 访问。</p>
<p>　　404(未找到)服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。<br>　　如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置(该文件应当位于顶级域，名为 robots.txt)。<br>　　如果对于 Googlebot 抓取的网址看到此状态码(在”诊断”标签的 HTTP 错误页面上)，则表示 Googlebot 跟随的可能是另一个页面的无效链接(是旧链接或输入有误的链接)。</p>
<p>　　405(方法禁用)禁用请求中指定的方法。</p>
<p>　　406(不接受)无法使用请求的内容特性响应请求的网页。</p>
<p>　　407(需要代理授权)此状态码与 401(未授权)类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。</p>
<p>　　408(请求超时)服务器等候请求时发生超时。</p>
<p>　　409(冲突)服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。</p>
<p>　　410(已删除)如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404(未找到)代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。</p>
<p>　　411(需要有效长度)服务器不接受不含有效内容长度标头字段的请求。</p>
<p>　　412(未满足前提条件)服务器未满足请求者在请求中设置的其中一个前提条件。</p>
<p>　　413(请求实体过大)服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</p>
<p>　　414(请求的 URI 过长)请求的 URI(通常为网址)过长，服务器无法处理。</p>
<p>　　415(不支持的媒体类型)请求的格式不受请求页面的支持。</p>
<p>　　416(请求范围不符合要求)如果页面无法提供请求的范围，则服务器会返回此状态码。</p>
<p>　　417(未满足期望值)服务器未满足”期望”请求标头字段的要求。</p>
<p>　　5xx(服务器错误)</p>
<p>　　这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p>
<p>　　500(服务器内部错误)服务器遇到错误，无法完成请求。</p>
<p>　　501(尚未实施)服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</p>
<p>　　502(错误网关)服务器作为网关或代理，从上游服务器收到无效响应。</p>
<p>　　503(服务不可用)服务器目前无法使用(由于超载或停机维护)。通常，这只是暂时状态。</p>
<p>　　504(网关超时)服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p>
<p>　　505(HTTP 版本不受支持)服务器不支持请求中所用的 HTTP 协议版本。</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/24/status/" data-id="cje153s7d0000r055adsg0ee9" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaSript/">JavaSript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/23/test/" class="article-date">
  <time datetime="2018-02-23T06:19:17.000Z" itemprop="datePublished">2018-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/23/test/">JavaSript模块化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>JavaSript模块化</p>
<pre><code>在了解AMD，CMD规范前，还是需要先来简单地了解下什么是模块化，模块化开发？

模块化是指在解决某一个复杂问题或者一系列的杂糅问题时，依照一种分类的思维把问题进行系统性的分解以之处理。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。可以想象一个巨大的系统代码，被整合优化分割成逻辑性很强的模块时，对于软件是一种何等意义的存在。对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。

还有一些对于模块化一些专业的定义为：模块化是软件系统的属性，这个系统被分解为一组高内聚，低耦合的模块。那么在理想状态下我们只需要完成自己部分的核心业务逻辑代码，其他方面的依赖可以通过直接加载被人已经写好模块进行使用即可。
</code></pre><p>首先，既然是模块化设计，那么作为一个模块化系统所必须的能力：</p>
<pre><code>1. 定义封装的模块。
2. 定义新模块对其他模块的依赖。
3. 可对其他模块的引入支持。

好了，思想有了，那么总要有点什么来建立一个模块化的规范制度吧，不然各式各样的模块加载方式只会将局搅得更为混乱。那么在JavaScript中出现了一些非传统模块开发方式的规范 CommonJS的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等。
</code></pre><p>AMD 与 RequireJS<br>AMD<br>    Asynchronous Module Definition，用白话文讲就是 异步模块定义，对于 JSer 来说，异步是再也熟悉不过的词了，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。</p>
<pre><code>AMD规范定义了一个自由变量或者说是全局变量 define 的函数。

define( id?, dependencies?, factory );    
AMD规范  https://github.com/amdjs/amdjs-api/wiki/AMD
第一个参数 id 为字符串类型，表示了模块标识，为可选参数。若不存在则模块标识应该默认定义为在加载器中被请求脚本的标识。如果存在，那么模块标识必须为顶层的或者一个绝对的标识。
第二个参数，dependencies ，是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。
第三个参数，factory，是一个需要进行实例化的函数或者一个对象。

创建模块标识为 alpha 的模块，依赖于 require， export，和标识为 beta 的模块  
</code></pre><p>define(“alpha”, [ “require”, “exports”, “beta” ], function( require, exports, beta ){<br>    export.verb = function(){<br>        return beta.verb();<br>        // or:<br>        return require(“beta”).verb();<br>    }<br>});</p>
<pre><code>一个返回对象字面量的异步模块
</code></pre><p>define([“alpha”], function( alpha ){<br>    return {<br>        verb : function(){<br>            return alpha.verb() + 1 ;<br>        }<br>    }<br>});</p>
<pre><code>无依赖模块可以直接使用对象字面量来定义
</code></pre><p>define( {<br>    add : function( x, y ){<br>        return x + y ;<br>    }<br>} );</p>
<pre><code>类似与 CommonJS 方式定义
</code></pre><p>define( function( require, exports, module){<br>    var a = require(‘a’),<br>          b = require(‘b’);</p>
<pre><code>exports.action = function(){};
</code></pre><p>} );</p>
<pre><code>require();  
require API 介绍 https://github.com/amdjs/amdjs-api/wiki/require

在 AMD 规范中的 require 函数与一般的 CommonJS中的 require 不同。由于动态检测依赖关系使加载异步，对于基于回调的 require 需求强烈。

局部 与 全局 的require
局部的 require 需要在AMD模式中的 define 工厂函数中传入 require。
</code></pre><p>define( [‘require’], function( require ){<br>  // …<br>} );<br>or：<br>define( function( require, exports, module ){<br>  // …<br>} );</p>
<pre><code>局部的 require 需要其他特定的 API 来实现。
全局的 require 函数是唯一全局作用域下的变量，像 define一样。全局的 require 并不是规范要求的，但是如果实现全局的 require函数，那么其需要具有与局部 require 函数 一样的以下的限定：
1. 模块标识视为绝对的，而不是相对的对应另一个模块标识。
2. 只有在异步情况下，require的回调方式才被用来作为交互操作使用。因为他不可能在同步的情况下通过 require(String) 从顶层加载模块。
依赖相关的API会开始模块加载。如果需要有互操作的多个加载器，那么全局的 reqiure 应该被加载顶层模块来代替。
</code></pre><p>require(String)<br>define( function( require ){<br>    var a = require(‘a’); // 加载模块a<br>} );</p>
<p>require(Array, Function)<br>define( function( require ){<br>    require( [‘a’, ‘b’], function( a,b ){ // 加载模块a b 使用<br>        // 依赖 a b 模块的运行代码<br>    } );<br>} );</p>
<p>require.toUrl( Url )<br>define( function( require ){<br>    var temp = require.toUrl(‘./temp/a.html’); // 加载页面<br>} );</p>
<pre><code>amdjs 的API   https://github.com/amdjs/amdjs-api/wiki
</code></pre><p>RequireJS<br>    官网 <a href="http://www.requirejs.org/" target="_blank" rel="noopener">http://www.requirejs.org/</a><br>    API <a href="http://www.requirejs.org/docs/api.html" target="_blank" rel="noopener">http://www.requirejs.org/docs/api.html</a></p>
<pre><code>RequireJS 是一个前端的模块化管理的工具库，遵循AMD规范，它的作者就是AMD规范的创始人 James Burke。所以说RequireJS是对AMD规范的阐述一点也不为过。

RequireJS 的基本思想为：通过一个函数来将所有所需要的或者说所依赖的模块实现装载进来，然后返回一个新的函数（模块），我们所有的关于新模块的业务代码都在这个函数内部操作，其内部也可无限制的使用已经加载进来的以来的模块。
</code></pre><script data-main="scripts/main" src="scripts/require.js"></script>

<pre><code>那么scripts下的main.js则是指定的主代码脚本文件，所有的依赖模块代码文件都将从该文件开始异步加载进入执行。

defined用于定义模块，RequireJS要求每个模块均放在独立的文件之中。按照是否有依赖其他模块的情况分为独立模块和非独立模块。
1. 独立模块，不依赖其他模块。直接定义：
</code></pre><p>define({<br>    method1: function(){},<br>    method2: function(){}<br>});</p>
<pre><code>也等价于
</code></pre><p>define(function(){<br>    return{<br>        method1: function(){},<br>        method2: function(){}<br>    }<br>});</p>
<pre><code>2. 非独立模块，对其他模块有依赖。
</code></pre><p>define([ ‘module1’, ‘module2’ ], function(m1, m2){<br>    …<br>});</p>
<pre><code>或者：
</code></pre><p>define( function( require ){<br>    var m1 = require( ‘module1’ ),<br>          m2 = require( ‘module2’ );<br>    …<br>});</p>
<pre><code>简单看了一下RequireJS的实现方式，其 require 实现只不过是将 function 字符串然后提取 require 之后的模块名，将其放入依赖关系之中。

require方法调用模块

在require进行调用模块时，其参数与define类似。
</code></pre><p>require( [‘foo’, ‘bar’], function( foo, bar ){<br>    foo.func();<br>    bar.func();<br>} );</p>
<pre><code>在加载 foo 与 bar 两个模块之后执行回调函数实现具体过程。

当然还可以如之前的例子中的，在define定义模块内部进行require调用模块
</code></pre><p>define( function( require ){<br>    var m1 = require( ‘module1’ ),<br>          m2 = require( ‘module2’ );<br>    …<br>});</p>
<pre><code>define 和 require 这两个定义模块，调用模块的方法合称为AMD模式，定义模块清晰，不会污染全局变量，清楚的显示依赖关系。AMD模式可以用于浏览器环境并且允许非同步加载模块，也可以按需动态加载模块。
</code></pre><p>CMD 与 seaJS<br>CMD<br>    在CMD中，一个模块就是一个文件，格式为：<br>    define( factory );</p>
<pre><code>全局函数define，用来定义模块。
参数 factory  可以是一个函数，也可以为对象或者字符串。
当 factory 为对象、字符串时，表示模块的接口就是该对象、字符串。

定义JSON数据模块：
</code></pre><p>define({ “foo”: “bar” });</p>
<pre><code>通过字符串定义模板模块：
</code></pre><p>define(‘this is .’);</p>
<pre><code>factory 为函数的时候，表示模块的构造方法，执行构造方法便可以得到模块向外提供的接口。
</code></pre><p>define( function(require, exports, module) {<br>    // 模块代码<br>});</p>
<pre><code>define( id?, deps?, factory );
define也可以接受两个以上的参数，字符串id为模块标识，数组deps为模块依赖：
</code></pre><p>define( ‘module’, [‘module1’, ‘module2’], function( require, exports, module ){<br>    // 模块代码<br>} );<br>    其与 AMD 规范用法不同。</p>
<pre><code>require 是 factory 的第一个参数。
require( id );
接受模块标识作为唯一的参数，用来获取其他模块提供的接口：
</code></pre><p>define(function( require, exports ){<br>    var a = require(‘./a’);<br>    a.doSomething();<br>});</p>
<pre><code>require.async( id, callback? );
require是同步往下执行的，需要的异步加载模块可以使用 require.async 来进行加载：
</code></pre><p>define( function(require, exports, module) {<br>    require.async(‘.a’, function(a){<br>        a.doSomething();<br>    });<br>});</p>
<pre><code>require.resolve( id )
可以使用模块内部的路径机制来返回模块路径，不会加载模块。

exports 是 factory 的第二个参数，用来向外提供模块接口。
</code></pre><p>define(function( require, exports ){<br>    exports.foo = ‘bar’; // 向外提供的属性<br>    exports.do = function(){}; // 向外提供的方法<br>});</p>
<pre><code>当然也可以使用 return 直接向外提供接口。
</code></pre><p>define(function( require, exports ){<br>    return{<br>        foo : ‘bar’, // 向外提供的属性<br>        do : function(){} // 向外提供的方法<br>    }<br>});</p>
<pre><code>也可以简化为直接对象字面量的形式:
</code></pre><p>define({<br>    foo : ‘bar’, // 向外提供的属性<br>    do : function(){} // 向外提供的方法<br>});</p>
<pre><code>与nodeJS中一样需要注意的是，一下方式是错误的：
</code></pre><p>define(function( require, exports ){<br>    exports = {<br>        foo : ‘bar’, // 向外提供的属性<br>        do : function(){} // 向外提供的方法<br>    }<br>});</p>
<pre><code>需要这么做
</code></pre><p>define(function( require, exports, module ){<br>    module.exports = {<br>        foo : ‘bar’, // 向外提供的属性<br>        do : function(){} // 向外提供的方法<br>    }<br>});</p>
<pre><code>传入的对象引用可以添加属性，一旦赋值一个新的对象，那么值钱传递进来的对象引用就会失效了。开始之初，exports 是作为 module.exports 的一个引用存在，一切行为只有在这个引用上 factory 才得以正常运行，赋值新的对象后就会断开引用，exports就只是一个新的对象引用，对于factory来说毫无意义，就会出错。

module 是factory的第三个参数，为一个对象，上面存储了一些与当前模块相关联的属性与方法。
    module.id 为模块的唯一标识。
    module.uri 根据模块系统的路径解析规则得到模块的绝对路径。
    module.dependencies 表示模块的依赖。
    module.exports 当前模块对外提供的接口。
</code></pre><p>seaJS<br>    官网 <a href="http://seajs.org/docs/" target="_blank" rel="noopener">http://seajs.org/docs/</a><br>    API快速参考 <a href="https://github.com/seajs/seajs/issues/266" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/266</a><br>    sea.js 核心特征：</p>
<pre><code>    1. 遵循CMD规范，与NodeJS般的书写模块代码。
    2. 依赖自动加载，配置清晰简洁。
兼容 Chrome 3+，Firefox 2+，Safari 3.2+，Opera 10+，IE 5.5+。

seajs.use 
用来在页面中加载一个或者多个模块
</code></pre><p>// 加载一个模块<br>seajs.use(‘./a’);<br>// 加载模块，加载完成时执行回调<br>seajs.use(‘./a’，function(a){<br>    a.doSomething();<br>});<br>// 加载多个模块执行回调<br>seajs.use([‘./a’,’./b’]，function(a , b){<br>    a.doSomething();<br>    b.doSomething();<br>});</p>
<pre><code>其define 与 require 使用方式基本就是CMD规范中的示例。
</code></pre><p>AMD 与 CMD 区别到底在哪里？</p>
<pre><code>看了以上 AMD，requireJS 与 CMD， seaJS的简单介绍会有点感觉模糊，总感觉较为相似。因为像 requireJS 其并不是只是纯粹的AMD固有思想，其也是有CMD规范的思想，只不过是推荐 AMD规范方式而已， seaJS也是一样。

下面是玉伯对于 AMD 与 CMD 区别的解释：

AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。

类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出还有不少??

这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。
目前这些规范的实现都能达成浏览器端模块化开发的目的。

区别：

1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：
</code></pre><p>// CMD<br>define(function(require, exports, module) {<br>    var a = require(‘./a’)<br>    a.doSomething()<br>    // 此处略去 100 行<br>    var b = require(‘./b’) // 依赖可以就近书写<br>    b.doSomething()<br>    // …<br>})</p>
<p>// AMD 默认推荐的是<br>define([‘./a’, ‘./b’], function(a, b) { // 依赖必须一开始就写好<br>    a.doSomething()<br>    // 此处略去 100 行<br>    b.doSomething()<br>    // …<br>})</p>
<p>虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。</p>
<pre><code>3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。
4. 还有一些细节差异，具体看这个规范的定义就好，就不多说了。
</code></pre><p>另外，SeaJS 和 RequireJS 的差异，可以参考：<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/277</a></p>
<p>总结</p>
<pre><code>本文主要是介绍了一下 AMD CMD的规范，顺便简单的讲述了一下 requireJS 与 seaJS。讲的较为笼统，下面的扩展阅读可以更好的帮助你理解模块化以及各个规范。
</code></pre><hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/23/test/" data-id="cje145glz00015055gef63uxs" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaSript/">JavaSript</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaSript/">JavaSript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JavaSript/" style="font-size: 10px;">JavaSript</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/24/status/">status</a>
          </li>
        
          <li>
            <a href="/2018/02/23/test/">JavaSript模块化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 SangJingRui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>