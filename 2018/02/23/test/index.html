<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JavaSript模块化 | My Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="模块化是指在解决某一个复杂问题或者一系列的杂糅问题时，依照一种分类的思维把问题进行系统性的分解以之处理。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。可以想象一个巨大的系统代码，被整合优化分割成逻辑性很强的模块时，对于软件是一种何等意义的存在。对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。 author：桑">
<meta name="keywords" content="JavaSript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSript模块化">
<meta property="og:url" content="https://sangshaoye.github.io/2018/02/23/test/index.html">
<meta property="og:site_name" content="My Blogs">
<meta property="og:description" content="模块化是指在解决某一个复杂问题或者一系列的杂糅问题时，依照一种分类的思维把问题进行系统性的分解以之处理。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。可以想象一个巨大的系统代码，被整合优化分割成逻辑性很强的模块时，对于软件是一种何等意义的存在。对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。 author：桑">
<meta property="og:updated_time" content="2018-05-30T03:38:51.264Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaSript模块化">
<meta name="twitter:description" content="模块化是指在解决某一个复杂问题或者一系列的杂糅问题时，依照一种分类的思维把问题进行系统性的分解以之处理。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。可以想象一个巨大的系统代码，被整合优化分割成逻辑性很强的模块时，对于软件是一种何等意义的存在。对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。 author：桑">
  
    <link rel="alternate" href="/atom.xml" title="My Blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">My Blogs</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">A man can&#39;t ride your back unless it is bent！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://sangshaoye.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/23/test/" class="article-date">
  <time datetime="2018-02-23T06:19:17.000Z" itemprop="datePublished">2018-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JavaSript模块化
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>模块化是指在解决某一个复杂问题或者一系列的杂糅问题时，依照一种分类的思维把问题进行系统性的分解以之处理。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。可以想象一个巨大的系统代码，被整合优化分割成逻辑性很强的模块时，对于软件是一种何等意义的存在。对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。</p>
<p>author：桑景瑞</p>
<a id="more"></a>
<hr>
<p>JavaSript模块化</p>
<pre><code>在了解AMD，CMD规范前，还是需要先来简单地了解下什么是模块化，模块化开发？

模块化是指在解决某一个复杂问题或者一系列的杂糅问题时，依照一种分类的思维把问题进行系统性的分解以之处理。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。可以想象一个巨大的系统代码，被整合优化分割成逻辑性很强的模块时，对于软件是一种何等意义的存在。对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。

还有一些对于模块化一些专业的定义为：模块化是软件系统的属性，这个系统被分解为一组高内聚，低耦合的模块。那么在理想状态下我们只需要完成自己部分的核心业务逻辑代码，其他方面的依赖可以通过直接加载被人已经写好模块进行使用即可。
</code></pre><p>首先，既然是模块化设计，那么作为一个模块化系统所必须的能力：</p>
<pre><code>1. 定义封装的模块。
2. 定义新模块对其他模块的依赖。
3. 可对其他模块的引入支持。

好了，思想有了，那么总要有点什么来建立一个模块化的规范制度吧，不然各式各样的模块加载方式只会将局搅得更为混乱。那么在JavaScript中出现了一些非传统模块开发方式的规范 CommonJS的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等。
</code></pre><p>AMD 与 RequireJS<br>AMD<br>    Asynchronous Module Definition，用白话文讲就是 异步模块定义，对于 JSer 来说，异步是再也熟悉不过的词了，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。</p>
<pre><code>AMD规范定义了一个自由变量或者说是全局变量 define 的函数。

define( id?, dependencies?, factory );    
AMD规范  https://github.com/amdjs/amdjs-api/wiki/AMD
第一个参数 id 为字符串类型，表示了模块标识，为可选参数。若不存在则模块标识应该默认定义为在加载器中被请求脚本的标识。如果存在，那么模块标识必须为顶层的或者一个绝对的标识。
第二个参数，dependencies ，是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。
第三个参数，factory，是一个需要进行实例化的函数或者一个对象。

创建模块标识为 alpha 的模块，依赖于 require， export，和标识为 beta 的模块  
</code></pre><p>define(“alpha”, [ “require”, “exports”, “beta” ], function( require, exports, beta ){<br>    export.verb = function(){<br>        return beta.verb();<br>        // or:<br>        return require(“beta”).verb();<br>    }<br>});</p>
<pre><code>一个返回对象字面量的异步模块
</code></pre><p>define([“alpha”], function( alpha ){<br>    return {<br>        verb : function(){<br>            return alpha.verb() + 1 ;<br>        }<br>    }<br>});</p>
<pre><code>无依赖模块可以直接使用对象字面量来定义
</code></pre><p>define( {<br>    add : function( x, y ){<br>        return x + y ;<br>    }<br>} );</p>
<pre><code>类似与 CommonJS 方式定义
</code></pre><p>define( function( require, exports, module){<br>    var a = require(‘a’),<br>          b = require(‘b’);</p>
<pre><code>exports.action = function(){};
</code></pre><p>} );</p>
<pre><code>require();  
require API 介绍 https://github.com/amdjs/amdjs-api/wiki/require

在 AMD 规范中的 require 函数与一般的 CommonJS中的 require 不同。由于动态检测依赖关系使加载异步，对于基于回调的 require 需求强烈。

局部 与 全局 的require
局部的 require 需要在AMD模式中的 define 工厂函数中传入 require。
</code></pre><p>define( [‘require’], function( require ){<br>  // …<br>} );<br>or：<br>define( function( require, exports, module ){<br>  // …<br>} );</p>
<pre><code>局部的 require 需要其他特定的 API 来实现。
全局的 require 函数是唯一全局作用域下的变量，像 define一样。全局的 require 并不是规范要求的，但是如果实现全局的 require函数，那么其需要具有与局部 require 函数 一样的以下的限定：
1. 模块标识视为绝对的，而不是相对的对应另一个模块标识。
2. 只有在异步情况下，require的回调方式才被用来作为交互操作使用。因为他不可能在同步的情况下通过 require(String) 从顶层加载模块。
依赖相关的API会开始模块加载。如果需要有互操作的多个加载器，那么全局的 reqiure 应该被加载顶层模块来代替。
</code></pre><p>require(String)<br>define( function( require ){<br>    var a = require(‘a’); // 加载模块a<br>} );</p>
<p>require(Array, Function)<br>define( function( require ){<br>    require( [‘a’, ‘b’], function( a,b ){ // 加载模块a b 使用<br>        // 依赖 a b 模块的运行代码<br>    } );<br>} );</p>
<p>require.toUrl( Url )<br>define( function( require ){<br>    var temp = require.toUrl(‘./temp/a.html’); // 加载页面<br>} );</p>
<pre><code>amdjs 的API   https://github.com/amdjs/amdjs-api/wiki
</code></pre><p>RequireJS<br>    官网 <a href="http://www.requirejs.org/" target="_blank" rel="noopener">http://www.requirejs.org/</a><br>    API <a href="http://www.requirejs.org/docs/api.html" target="_blank" rel="noopener">http://www.requirejs.org/docs/api.html</a></p>
<pre><code>RequireJS 是一个前端的模块化管理的工具库，遵循AMD规范，它的作者就是AMD规范的创始人 James Burke。所以说RequireJS是对AMD规范的阐述一点也不为过。

RequireJS 的基本思想为：通过一个函数来将所有所需要的或者说所依赖的模块实现装载进来，然后返回一个新的函数（模块），我们所有的关于新模块的业务代码都在这个函数内部操作，其内部也可无限制的使用已经加载进来的以来的模块。
</code></pre><script data-main="scripts/main" src="scripts/require.js"></script>

<pre><code>那么scripts下的main.js则是指定的主代码脚本文件，所有的依赖模块代码文件都将从该文件开始异步加载进入执行。

defined用于定义模块，RequireJS要求每个模块均放在独立的文件之中。按照是否有依赖其他模块的情况分为独立模块和非独立模块。
1. 独立模块，不依赖其他模块。直接定义：
</code></pre><p>define({<br>    method1: function(){},<br>    method2: function(){}<br>});</p>
<pre><code>也等价于
</code></pre><p>define(function(){<br>    return{<br>        method1: function(){},<br>        method2: function(){}<br>    }<br>});</p>
<pre><code>2. 非独立模块，对其他模块有依赖。
</code></pre><p>define([ ‘module1’, ‘module2’ ], function(m1, m2){<br>    …<br>});</p>
<pre><code>或者：
</code></pre><p>define( function( require ){<br>    var m1 = require( ‘module1’ ),<br>          m2 = require( ‘module2’ );<br>    …<br>});</p>
<pre><code>简单看了一下RequireJS的实现方式，其 require 实现只不过是将 function 字符串然后提取 require 之后的模块名，将其放入依赖关系之中。

require方法调用模块

在require进行调用模块时，其参数与define类似。
</code></pre><p>require( [‘foo’, ‘bar’], function( foo, bar ){<br>    foo.func();<br>    bar.func();<br>} );</p>
<pre><code>在加载 foo 与 bar 两个模块之后执行回调函数实现具体过程。

当然还可以如之前的例子中的，在define定义模块内部进行require调用模块
</code></pre><p>define( function( require ){<br>    var m1 = require( ‘module1’ ),<br>          m2 = require( ‘module2’ );<br>    …<br>});</p>
<pre><code>define 和 require 这两个定义模块，调用模块的方法合称为AMD模式，定义模块清晰，不会污染全局变量，清楚的显示依赖关系。AMD模式可以用于浏览器环境并且允许非同步加载模块，也可以按需动态加载模块。
</code></pre><p>CMD 与 seaJS<br>CMD<br>    在CMD中，一个模块就是一个文件，格式为：<br>    define( factory );</p>
<pre><code>全局函数define，用来定义模块。
参数 factory  可以是一个函数，也可以为对象或者字符串。
当 factory 为对象、字符串时，表示模块的接口就是该对象、字符串。

定义JSON数据模块：
</code></pre><p>define({ “foo”: “bar” });</p>
<pre><code>通过字符串定义模板模块：
</code></pre><p>define(‘this is .’);</p>
<pre><code>factory 为函数的时候，表示模块的构造方法，执行构造方法便可以得到模块向外提供的接口。
</code></pre><p>define( function(require, exports, module) {<br>    // 模块代码<br>});</p>
<pre><code>define( id?, deps?, factory );
define也可以接受两个以上的参数，字符串id为模块标识，数组deps为模块依赖：
</code></pre><p>define( ‘module’, [‘module1’, ‘module2’], function( require, exports, module ){<br>    // 模块代码<br>} );<br>    其与 AMD 规范用法不同。</p>
<pre><code>require 是 factory 的第一个参数。
require( id );
接受模块标识作为唯一的参数，用来获取其他模块提供的接口：
</code></pre><p>define(function( require, exports ){<br>    var a = require(‘./a’);<br>    a.doSomething();<br>});</p>
<pre><code>require.async( id, callback? );
require是同步往下执行的，需要的异步加载模块可以使用 require.async 来进行加载：
</code></pre><p>define( function(require, exports, module) {<br>    require.async(‘.a’, function(a){<br>        a.doSomething();<br>    });<br>});</p>
<pre><code>require.resolve( id )
可以使用模块内部的路径机制来返回模块路径，不会加载模块。

exports 是 factory 的第二个参数，用来向外提供模块接口。
</code></pre><p>define(function( require, exports ){<br>    exports.foo = ‘bar’; // 向外提供的属性<br>    exports.do = function(){}; // 向外提供的方法<br>});</p>
<pre><code>当然也可以使用 return 直接向外提供接口。
</code></pre><p>define(function( require, exports ){<br>    return{<br>        foo : ‘bar’, // 向外提供的属性<br>        do : function(){} // 向外提供的方法<br>    }<br>});</p>
<pre><code>也可以简化为直接对象字面量的形式:
</code></pre><p>define({<br>    foo : ‘bar’, // 向外提供的属性<br>    do : function(){} // 向外提供的方法<br>});</p>
<pre><code>与nodeJS中一样需要注意的是，一下方式是错误的：
</code></pre><p>define(function( require, exports ){<br>    exports = {<br>        foo : ‘bar’, // 向外提供的属性<br>        do : function(){} // 向外提供的方法<br>    }<br>});</p>
<pre><code>需要这么做
</code></pre><p>define(function( require, exports, module ){<br>    module.exports = {<br>        foo : ‘bar’, // 向外提供的属性<br>        do : function(){} // 向外提供的方法<br>    }<br>});</p>
<pre><code>传入的对象引用可以添加属性，一旦赋值一个新的对象，那么值钱传递进来的对象引用就会失效了。开始之初，exports 是作为 module.exports 的一个引用存在，一切行为只有在这个引用上 factory 才得以正常运行，赋值新的对象后就会断开引用，exports就只是一个新的对象引用，对于factory来说毫无意义，就会出错。

module 是factory的第三个参数，为一个对象，上面存储了一些与当前模块相关联的属性与方法。
    module.id 为模块的唯一标识。
    module.uri 根据模块系统的路径解析规则得到模块的绝对路径。
    module.dependencies 表示模块的依赖。
    module.exports 当前模块对外提供的接口。
</code></pre><p>seaJS<br>    官网 <a href="http://seajs.org/docs/" target="_blank" rel="noopener">http://seajs.org/docs/</a><br>    API快速参考 <a href="https://github.com/seajs/seajs/issues/266" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/266</a><br>    sea.js 核心特征：</p>
<pre><code>    1. 遵循CMD规范，与NodeJS般的书写模块代码。
    2. 依赖自动加载，配置清晰简洁。
兼容 Chrome 3+，Firefox 2+，Safari 3.2+，Opera 10+，IE 5.5+。

seajs.use 
用来在页面中加载一个或者多个模块
</code></pre><p>// 加载一个模块<br>seajs.use(‘./a’);<br>// 加载模块，加载完成时执行回调<br>seajs.use(‘./a’，function(a){<br>    a.doSomething();<br>});<br>// 加载多个模块执行回调<br>seajs.use([‘./a’,’./b’]，function(a , b){<br>    a.doSomething();<br>    b.doSomething();<br>});</p>
<pre><code>其define 与 require 使用方式基本就是CMD规范中的示例。
</code></pre><p>AMD 与 CMD 区别到底在哪里？</p>
<pre><code>看了以上 AMD，requireJS 与 CMD， seaJS的简单介绍会有点感觉模糊，总感觉较为相似。因为像 requireJS 其并不是只是纯粹的AMD固有思想，其也是有CMD规范的思想，只不过是推荐 AMD规范方式而已， seaJS也是一样。

下面是玉伯对于 AMD 与 CMD 区别的解释：

AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。

类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出还有不少??

这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。
目前这些规范的实现都能达成浏览器端模块化开发的目的。

区别：

1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：
</code></pre><p>// CMD<br>define(function(require, exports, module) {<br>    var a = require(‘./a’)<br>    a.doSomething()<br>    // 此处略去 100 行<br>    var b = require(‘./b’) // 依赖可以就近书写<br>    b.doSomething()<br>    // …<br>})</p>
<p>// AMD 默认推荐的是<br>define([‘./a’, ‘./b’], function(a, b) { // 依赖必须一开始就写好<br>    a.doSomething()<br>    // 此处略去 100 行<br>    b.doSomething()<br>    // …<br>})</p>
<p>虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。</p>
<pre><code>3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。
4. 还有一些细节差异，具体看这个规范的定义就好，就不多说了。
</code></pre><p>另外，SeaJS 和 RequireJS 的差异，可以参考：<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/277</a></p>
<p>总结<br>    本文主要是介绍了一下 AMD CMD的规范，顺便简单的讲述了一下 requireJS 与 seaJS。讲的较为笼统，下面的扩展阅读可以更好的帮助你理解模块化以及各个规范。</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sangshaoye.github.io/2018/02/23/test/" data-id="cjhad4b9s000ivs554wz0ui5j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaSript/">JavaSript</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/02/24/status/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          status
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaSript/">JavaSript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LIUNX/">LIUNX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NGINX/">NGINX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/angular/">angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端日常问题/">前端日常问题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JAVA/" style="font-size: 10px;">JAVA</a> <a href="/tags/JavaSript/" style="font-size: 20px;">JavaSript</a> <a href="/tags/LIUNX/" style="font-size: 15px;">LIUNX</a> <a href="/tags/NGINX/" style="font-size: 10px;">NGINX</a> <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/前端日常问题/" style="font-size: 10px;">前端日常问题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/28/webapck配置中chunkname/">chunkname</a>
          </li>
        
          <li>
            <a href="/2018/06/26/loader/">loader</a>
          </li>
        
          <li>
            <a href="/2018/03/26/PS1/">PS1</a>
          </li>
        
          <li>
            <a href="/2018/03/22/放大镜/">放大镜</a>
          </li>
        
          <li>
            <a href="/2018/03/19/angular/">angular搭建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 SangJingRui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>